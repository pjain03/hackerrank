The Problem: https://www.hackerrank.com/challenges/travel-around-the-world/problem
Backhistory: I worked on this one earlier this summer before taking my algorithms class. Lets see if I can apply what I learnt to this.

Started out with a very naive basic solution. 
Timed out on basically everything. O(N^2) time.

Looks to be a Dynamic Programming problem of sorts. 

I wonder if we even need to compare every city to every other...
0. diff = a - b for all a, b pairs.
1. Store all values in diff < 0 since those are the only ones which would cause potential problems.
2. Pick every one for which diff < 0 and go backwards marking each as invalid? reducing our count of valid cities?

Any invalid city reached already has been considered then...
So in essence we only go through N cities for every city... but not all these combinations are unique. There are N^2 combinations but they can be encoded so:
N + N cities. Start from 0th city, go through all N, end at 0. Start at 1, go through all, reach 0, go to 1. and so on...

This idea has failed drastically. It's given me lower values than before.